@startuml LLM Integration Architecture
!theme plain
title AgentCrafter - LLM Integration Architecture

package "DSL Layer" {
  trait LLMQLearning {
    -llmConfig: LLMConfig
    +useLLM(block: LLMConfig ?=> Unit): Unit
    +simulation(block: SimulationWrapper ?=> Unit): Unit
  }
  
  class LLMConfig {
    +enabled: Boolean
    +model: String
    +wallsEnabled: Boolean
    +wallsModel: String
    +wallsPrompt: String
  }
  
  enum LLMProperty {
    Enabled
    Model
    WallsEnabled
    WallsModel
    WallsPrompt
    +>>(value: T): Unit
  }
}

package "LLM Services" {
  class LLMApiClient {
    -apiKey: String
    -baseUrl: String
    +generateQTable(prompt: String, model: String): Option[String]
    +generateWalls(prompt: String, model: String): Option[String]
    +makeApiCall(prompt: String, model: String): String
    -buildRequestPayload(prompt: String, model: String): String
    -parseResponse(response: String): Option[String]
  }
  
  class LLMQTableService {
    +loadQTableFromLLM(builder: SimulationBuilder, model: String, filePath: String): Option[String]
    +loadQTableIntoAgents(builder: SimulationBuilder, qTableJson: String): Unit
    -generateQTablePrompt(world: WorldSpec): String
    -parseQTableResponse(response: String): Map[(State, Action), Double]
  }
  
  class LLMWallService {
    +generateWallsFromPrompt(prompt: String, model: String, rows: Int, cols: Int): Set[State]
    -parseWallResponse(response: String, rows: Int, cols: Int): Set[State]
    -validateWallConfiguration(walls: Set[State], rows: Int, cols: Int): Boolean
  }
  
  class QTableLoader {
    +loadFromJson(json: String): Map[(State, Action), Double]
    +validateQTable(qTable: Map[(State, Action), Double], world: WorldSpec): Boolean
    -parseQTableEntry(entry: String): Option[((State, Action), Double)]
  }
}

package "Prompt Management" {
  object Prompts {
    +QTABLE_GENERATION_PROMPT: String
    +WALL_GENERATION_PROMPT: String
    +buildQTablePrompt(world: WorldSpec): String
    +buildWallPrompt(description: String, dimensions: (Int, Int)): String
  }
}

package "External API" {
  cloud "OpenAI API" as OpenAI {
    interface "GPT-4o" as GPT4
    interface "GPT-3.5-turbo" as GPT35
  }
}

package "Integration Points" {
  class SimulationBuilder {
    +wallsFromLLM(config: WallLLMConfig): SimulationBuilder
    +addLLMGeneratedWalls(walls: Set[State]): Unit
  }
  
  class AgentBuilder {
    +withLLMQTable(enabled: Boolean): AgentBuilder
  }
  
  class WallLLMConfig {
    +model: String
    +prompt: String
  }
}

' Relationships
LLMQLearning --> LLMConfig : manages
LLMProperty --> LLMConfig : configures

LLMQTableService --> LLMApiClient : uses
LLMWallService --> LLMApiClient : uses
LLMApiClient --> OpenAI : calls

LLMQTableService --> QTableLoader : uses
LLMQTableService --> Prompts : uses
LLMWallService --> Prompts : uses

SimulationBuilder --> LLMWallService : uses
AgentBuilder --> LLMQTableService : uses
SimulationBuilder --> WallLLMConfig : accepts

' Flow annotations
note right of LLMQLearning
  **DSL Integration:**
  useLLM {
    Enabled >> true
    Model >> "gpt-4o"
  }
  
  wallsFromLLM {
    Model >> "gpt-4o"
    Prompt >> "Create a maze..."
  }
end note

note right of LLMApiClient
  **API Communication:**
  • Handles OpenAI API authentication
  • Manages request/response formatting
  • Implements retry logic and error handling
  • Supports multiple GPT models
end note

note bottom of LLMQTableService
  **Q-Table Generation Process:**
  1. Analyze simulation configuration
  2. Generate context-aware prompt
  3. Call LLM API with world description
  4. Parse JSON response into Q-table
  5. Validate and inject into agents
end note

note bottom of LLMWallService
  **Wall Generation Process:**
  1. Receive natural language description
  2. Build structured prompt with constraints
  3. Call LLM API for wall layout
  4. Parse response into wall coordinates
  5. Validate against grid dimensions
end note

@enduml