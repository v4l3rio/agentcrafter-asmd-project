package agentcrafter.llmqlearning

import agentcrafter.common.{Action, Learner, QLearner, State}
import play.api.libs.json.*

import scala.collection.mutable
import scala.util.control.NonFatal
import scala.util.{Failure, Success, Try}

/**
 * Utility object for serializing and deserializing Q-tables to/from JSON format.
 *
 * This object provides functionality to convert Q-tables between their internal
 * representation and JSON format, enabling persistence, LLM integration, and
 * data exchange between different components of the system.
 */
object QTableLoader:

  private given actionFormat: Format[Action] = new Format[Action]:
    private val map = Action.values.map(a => a.toString -> a).toMap

    def reads(j: JsValue): JsResult[Action] =
      j.validate[String].flatMap { str =>
        map.get(str) match
          case Some(a) => JsSuccess(a)
          case None => JsError(s"unknown Action '$str'")
      }

    def writes(a: Action): JsValue = JsString(a.toString)

  private val stateRegex = """\((\d+)\s*,\s*(\d+)\)""".r

  private given stateKeyFormat: Format[State] = new Format[State]:
    def reads(j: JsValue): JsResult[State] = j.validate[String].flatMap {
      case stateRegex(r, c) => JsSuccess(State(r.toInt, c.toInt))
      case other => JsError(s"invalid state key '$other'")
    }

    def writes(s: State): JsValue = JsString(s"(${s.x}, ${s.y})")

  private given qTableReads: Reads[Map[(State, Action), Double]] = Reads { json =>
    json.validate[Map[State, Map[Action, Double]]].map { nested =>
      nested.flatMap { case (st, actMap) => actMap.view.map { case (a, v) => (st, a) -> v } }
    }
  }

  private given qTableWrites: Writes[Map[(State, Action), Double]] = Writes { map =>
    val grouped: Map[State, Map[Action, Double]] =
      map.groupMapReduce(_._1._1) { case ((_, a), v) => Map(a -> v) }(_ ++ _)
    Json.toJson(grouped)
  }


  /**
   * Loads a Q-table from JSON string into a learner instance.
   *
   * This method parses JSON data (potentially generated by an LLM) and injects
   * the Q-values into the specified learner using reflection. The JSON is cleaned
   * of common LLM decorations before parsing.
   *
   * @param raw     Raw JSON string containing Q-table data
   * @param learner The learner instance to load the Q-table into
   * @return Success if loading succeeded, Failure with error details if it failed
   */
  def loadQTableFromJson(raw: String, learner: Learner): Try[Unit] =
    learner match
      case ql: QLearner =>
        for
          cleaned <- Success(stripLlMDecorations(raw))
          table <- Json.parse(cleaned).validate[Map[(State, Action), Double]].asEither
            .fold(err => Failure(new RuntimeException(err.toString)), Success.apply)
          _ <- inject(ql, table)
        yield ()
      case _ => Failure(new IllegalArgumentException("Unsupported learner implementation"))

  /**
   * Serializes a learner's Q-table to a formatted JSON string.
   *
   * @param learner The learner whose Q-table should be serialized
   * @return A pretty-printed JSON string representation of the Q-table
   */
  def qTableToJson(learner: Learner): String =
    Json.prettyPrint(Json.toJson(learner.QTableSnapshot))

  private def stripLlMDecorations(s: String): String =
    val noTicks =
      if s.trim.startsWith("```") then s.trim.stripPrefix("```json").stripPrefix("```").stripSuffix("```")
      else s
    noTicks.replaceAll("(?i)^json\\s*", "").replaceAll("(?i)^here.*?:\\s*", "").trim

  private def inject(learner: QLearner, table: Map[(State, Action), Double]) = Try {
    val qField = learner.getClass.getDeclaredField("Q")
    qField.setAccessible(true)
    val qTable = qField.get(learner)

    val mapField = qTable.getClass.getDeclaredField("table")
    mapField.setAccessible(true)
    val internal = mapField.get(qTable).asInstanceOf[mutable.Map[(State, Action), Double]]

    internal ++= table // bulk update
  }.recoverWith { case NonFatal(e) =>
    Failure(new RuntimeException("Failed to inject Qâ€‘values via reflection: " + e.getMessage, e))
  }
